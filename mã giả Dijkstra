Thuật toán Dijkstra(s):
    Khởi tạo khoảng cách d[i] = ∞ với mọi đỉnh i
    d[s] = 0   // khoảng cách từ s đến chính nó là 0

    Khởi tạo hàng đợi ưu tiên pq (min-heap) lưu các cặp (đỉnh, khoảng cách)
    pq.push((s, 0))

    Trong khi pq chưa rỗng:
        (u, dis) = pq.top()  // lấy đỉnh có khoảng cách nhỏ nhất
        pq.pop()

        Nếu dis > d[u]:  // đã có đường đi ngắn hơn trước đó
            Bỏ qua u (continue)

        Duyệt tất cả các đỉnh kề v của u:
            Giả sử cạnh (u, v) có trọng số uv

            Nếu d[v] > d[u] + uv:
                d[v] = d[u] + uv
                pq.push((v, d[v]))

Ý tưởng:
+ Xét tại 1 đỉnh u mình sẽ duyệt danh sách v kề của đỉnh đó, nếu khoảng cách đỉnh kề v (được lưu trong mảng d) nhỏ hơn khoảng cách của đỉnh u là d[u] + cạnh uv thì mình sẽ cập nhật đỉnh v và push đỉnh v 
vào xét lại đường đi.
+ Dùng pq để đảm bảo những đỉnh có trọng số nhỏ hơn xét trước và update cho mảng d là cái chuẩn mực để so sánh
những đỉnh lớn hơn phía sau sẽ bỏ qua. Còn nếu ta khoonh dùng pq có thể là xét những đỉnh có trọng số lớn hơn trước
tốn thêm thời gian và sau đó mới xét những đỉnh nhỏ và update, thế thì tại sao ta không update đỉnh nhỏ rồi nếu đỉnh lớn
hơn vô nghĩa thì ta loại nó ra là được.
+ Chú ý dòng code Nếu dis > d[u]:
Một đỉnh u có thể duyệt lại nhiều lần vì có nhiều đường đi đến nó, khi duyệt lại tới đỉnh u mà dis_u > d[u] thì cái đường đi đó vô nghĩa vì nó vốn đã lớn hơn đường đi hiện tại và không cần phải duyệt tiếp,
nếu không cẩn thận bước này code sẽ bị TLE. 
Giải thích rõ hơn: d[u] là đường đi từ đỉnh s cho tới đỉnh u và là đường đi nhỏ nhất tối ưu, trong khi đó dis là 1 trường
hợp khác đến đỉnh u mới được thêm vào.Thì nếu mình có d[u] đã tối ưu rồi, thì cái trường hợp khác
từ s đến u là dis vô nghĩa.
Ví dụ : đường đi từ 5 đến 3 là 2, trong khi đó 6 đến 3 là 9. nếu ngay từ ban đầu mình cập
nhật từ 5 đến 3 là 2, thì 2 là cái chuẩn mực phải nhỏ hơn 2 thì mình mới xét tiếp.
