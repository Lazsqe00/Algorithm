Thuật toán kiểm tra chu trình có thể dùng để kiểm tra coi có chu trình nào có độ dài chẵn hay lẻ không thì được. Nhưng nếu dùng để kiểm tra trọng số của chu trình sẽ bị sai, nếu code đúng 100% sẽ bị TLE. 

void DFS(int u){
	visited[u] = true;
	for(auto v : adj[u]){
		if(!visited[v.fi]){
			par[v.fi] = u;
			high[v.fi] = high[u] + 1;
			dist[v.fi] = dist[u] + v.se;
			DFS(v.fi);
		}
		else if(v.fi != par[u]){
			if(dist[u] - dist[v.fi] + v.se < d && high[u] - high[v.fi] + 1 >= 3){
				d = dist[u] - dist[v.fi] + v.se;
				max_len = high[u] - high[v.fi] + 1;
			}
		}
	}
	visited[u] = false;
}

Nếu k thêm dòng visited[u] = false; thuật toán này sẽ kiểm tra thiếu chu trình nhỏ con bên trong nó nhưng nếu chỉ kiểm tra coi có chu trình lẻ hay không thì k cần có visited[u] = false; 
vì 1 chu trình lớn có thể tách ra làm nhiều chu trình con phía bên trong đó, nếu chu trình lớn nó lẻ thì chắc chắn tồn tại 1 số chu trình con bên nó lẻ do đó ta cứ duyệt từng chu trình 
con mà kiểm tra. (tên bt: Đồ thị). Nhưng nếu bài toán đó mỗi chu trình là 1 kết quả độc lập thì không thể duyệt như thế được.

NÓI CHUNG KHI LIÊN QUAN TỚI BÀI TOÁN CHU TRÌNH THÊM DÒNG visited[u] = false; sẽ làm code đúng nhưng thuật toán sẽ rất chậm và nguy cơ bị TLE lên tới 99%
Đoạn code trên mục đích tìm 1 chu trình có nhiều đỉnh nhất sao cho chi phí đến các đỉnh là ít nhất. Trường hợp nó tìm thấy 1 chu trình con
bên trong, nhưng đáp án là chu trình bự bao bên ngoài. Tưởng tượng 1 hình bình hành và cắt 1 nữa tam giác là chu trình con
Thì bài toán ở đây đó là do nó nối cạnh cuối cùng tam giác dẫn tới nó không thể quay lại cái đỉnh nối đó để tìm ra chu trình lớn bên ngoài
do đó để nó quay lại ta phải cho visited = false => code chậm.

