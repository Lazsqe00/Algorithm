Dạng toán liên quan đến Dijkstra
1. Tìm đường đi ngắn nhất từ 1 đến N, hỏi có bao nhiêu đường đi?
Gọi cnt[i] là số đường đi ngắn nhất đến đỉnh i. Khởi tạo cnt[1] = 1. Đáp án bài toán là cnt[N]
Nếu du + dv < F[u] -> cnt[v] = cnt[u], else if(du + dv == F[u]) cnt[v] += cnt[u]

2. Hãy loại bỏ đỉnh u sao cho đường đi ngắn nhất từ 1 đến N vẫn không đổi.
Gọi F1, FN, F lần lượt là đường đi ngắn nhất từ 1 đến u, từ N đến u và từ 1 đến N
=> F1[u] + FN[u] = F[N]
Nhưng cách làm này vẫn chưa đúng vì có thể có rất nhiều đường đi ngắn nhất từ 1 đến N.
Nghĩa là có đường đi ngắn nhất đi qua i và 1 đường đi ngắn nhất khác không đi qua i.
Nếu ta bỏ đỉnh i thì đường đi ngắn nhất vẫn không đổi. Như vậy, ta cần thêm bước đếm số đường đi ngắn nhất:
Gọi cnt1[u] = số đường ngắn nhất từ 1 đến u.
Gọi cntN[u] = số đường ngắn nhất từ u đến N.
Tổng số đường ngắn nhất = cnt1[N].
=> cnt1[u] * cntN[u] == cnt1[N] (tức là mọi đường ngắn nhất đều đi qua u). Thì lúc này không thể bỏ u.
Code minh họa:
if(F1[i] + FN[i] != F1[N]) rs.push_back(i);
else if(F1[i] + FN[i] == F1[N]){
	  if(1ll * cnt1[i] * cntN[i] != cnt1[N]){
				rs.push_back(i);
		}
}

3. Đề cho 1 sơ đồ đường đi 1 chiều liên thông chứa 2 đỉnh s và t, và cho một danh sách đề xuất đường đi 2 chiều. Và mình bắt buộc phải chọn 
1 trong danh sách để đoạn từ s đến t là nhỏ nhất
Gọi F1[], FN[] lần lượt là khoảng cách từ 1 đến mọi đỉnh và khoảng cách từ N đến mọi đỉnh. Nhận thấy vì đường đi 1 chiều nên nếu u -> N thì
đảo chiều adj_rev N -> u.
Với 1 đỉnh x và y trong danh sách ta sẽ cập nhật res = min({res, F1[x] + FN[y] + w, F1[y] + FN[x] + w}) vì x và y là đường đi 2 chiều nên
sẽ có 2 trường hợp xảy ra nếu ta thêm tuyến đường x và y 2 chiều vào.
