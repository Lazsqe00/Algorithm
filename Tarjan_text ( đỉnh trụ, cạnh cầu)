/*
Thuật toán Tarjan

B1: Khởi tạo đánh số các đỉnh trên đồ thị, dùng một mảng sta[MAX] để đánh số, và mảng low[MAX] (low link) hay liên kết thấp nhất
để cập nhật đường nối giữa đỉnh u và tổ tiên v xa nhất của nó (sta[v] càng nhỏ thì liên kết càng thấp)

B2: Duyệt DFS, nếu đỉnh u quay lại đc tổ tiên của nó thì có nhiều trường hợp, nếu u quay lại được nhiều tổ tiên (có nhiều vòng cung)
-> thì liên kết thấp nhất phải là tổ tiên xa nhất -> do đó cập nhật low[u] = min(low[u], sta[v]).

Khi low u được cập nhật, u trở thành đỉnh v1, các đỉnh u có đường đi tới v1 trước đó cũng sẽ được cập nhật low
-> low[u] = min(low[u], low[v1]), dùng min vì có trường hợp v1 (nó k gặp đc tổ tiên, thì low[v1] nó vẫn là sta[v1]) lúc này v1 lớn hơn u
nên v1 không cập nhật

VD: 1 -> 2 -> 3 -> 4 -> 2. khi tới 4 nó quay về 2 ta cập nhật liên kết thấp nhất là tổ tiên của nó (chú ý nó có thể có nhiều tổ tiên)
=> low[u] = min(low[u], sta[v]). khi đó low[4] nó được cập nhật thì khi quay về 3 ta phải cập nhật dựa trên low[4] nên low[u] = min(low[u], low[v1]),
trong đó v1 là đỉnh 4 và cũng là đỉnh u trước đó.

TH2: 1 -> 2 -> 3 -> 1 và 2 -> 4 -> 3 -> 1. (2 hình tam giác). 
1 -- 2
|  / |
3 -- 4
DFS giả sử đi theo nhánh 1 → 2 → 4 → 3, thì tại 3 có 2 sự lựa chọn đến 2 hoặc 1, thì 4 nó sẽ cập nhật được dựa trên 2 tổ tiên 2 và 1.

Tư tưởng chung: low luôn bằng với sta nếu không có chu trình, nếu có chu trình chỉ có low thay đổi để lưu liên kết thấp nhất với tổ tiên
nếu có nhiều chu trình thì low sẽ cập nhật chu trình có tổ tiên xa nhất. Mục đích nếu cạnh u,v là cạnh cầu khi v không móc được tới tổ tiên của 
u hoặc là v không móc được tới u => low[v] > sta[u]. VD 2 -> 3 -> 1 -> 2, 3 móc được tới 2 nên cạnh 23 này không phải cạnh cầu.
Tương tự về đỉnh trụ nhưng với chu trình trên dấu "=" xảy trong trường hợp u không phải là gốc của cây, và chú ý gốc của cây phải từ 2 nhánh
trở lên mới tính là đỉnh trụ. VD 1 -> 2 -> 3 -> 1. Sau khi chạy tới cặp cuối cùng u = 3. v = 1 => update low[2,3] = 1. Khi quay lui về
1 thì cặp u và v đầu tiên là u = 1 và v = 2 mặc dù low[2] = sta[1] nhưng par(1) = 0 nên ta không xét.

Về đỉnh trụ: (công thức khác cạnh cầu)

Ta có 3 đỉnh 1 - 2 - 3, đỉnh 2 là đỉnh trụ. Bởi vì 3 không có liên kết đến tổ tiên có 2, do đó bắt buộc phải đi qua đỉnh 2.
-> suy ra low[3] >= sta[2], dấu bằng xảy ra trong trường hợp 2 là gốc của chu trình (ta thêm đỉnh 4 nối với 2 và 3 để tạo thành chu trình)
và u không phải là gốc của cây

Nếu u là đỉnh trụ khi và chỉ khi: low[v] >= sta[u], riêng gốc cây thì phải xét riêng, nếu gốc cây có 1 nhánh thì k phải đỉnh trụ
gốc từ 2 nhánh trở lên ta xem gốc đó 100% là đỉnh trụ

Chú ý: Khi kiểm tra điều kiện low[v] >= sta[u], 1 đỉnh u có thể có nhiều đỉnh v do đó đỉnh u có thể bị nhét vào nhiều lần vì vậy 
ta phải dùng set để lưu các đỉnh không trùng lặp


Về cạnh cầu: (công thức không lấy dấu = )

Nếu u và v là cạnh cầu khi và chỉ khi: low[v] > sta[u] (không có liên kết từ v đến tổ tiên của u do đó bắt buộc phải đi qua đỉnh u, khi đó nếu bỏ cạnh uv sẽ tăng số tplt),
(nếu có dấu "=" thì trường hợp nó chu trình (u là gốc chu trình) khi đó nếu bỏ cạnh u v thì liên kết nó vẫn không thay đổi, bởi vì vẫn còn 1 cạnh u->v1 khác, do đó k lấy dấu =.

*/
